## Blackjack Project

###How to Run This Project

This project is run from the Saloon class. Run the project from the Saloon class and follow the prompts on the screen to play blackjack.

###Project Description

You're an outlaw on the run and you come across a seedy-looking saloon in a small sleepy town. You need more cash fast to get back East, and with the law on your heels, you'll have to earn it the hard way - over the blackjack table. You choose a name and starting cash, and you can keep playing blackjack hands until you choose to leave the program (later versions will have cash wagering, but version 1.0 does not utilize cash wagering). As of version 1.0, aces are always 11.

The project ties together most of the classes and logic in the in the Saloon class, including an opening introduction. A Player class and a Dealer class both implement a PlayingBlackjack interface. The Player class and the Dealer class both use their own versions of a hitMe method that allow the dealer or player to draw a card - the player's hitMe method is executed based on user input, while the dealer's hitMe method is executed based on blackjack rules and logic. The Player class in later versions will also handle the betting and wagering logic as well as doubling down, splitting, etc.

Most of the "game" logic for blackjack is handled in the PlayerHand and DealerHand class, each of which extend an abstract class HandOfCards. The majority of the blackjack game rules are executed from the shared HandOfCards class, but there are a few specific differences between the PlayerHand and DealerHand classes, such as the DealerHand class displaying only one card at the first deal and the PlayerHand class displaying both. 

The Dealer class has a Deck, the logic of which is handled in the Deck class. The Deck class handles most of the logic directly related to the mechanics of the Cards themselves - the Deck class handles the Card objects, creating an array of 52 unique Card objects, and shuffling them. Although the deck "deals a card" itself, it always passes the dealt Card object to the Dealer class, and it's the Dealer class that calls on deck methods. In addition, although the Deck class has a method that checks its size, the Dealer class handles the construction of a new Deck object when the deck runs out of cards.  

###Lessons Learned

I'm starting to get better about thinking in terms of objects and determining which objects should hold which methods, but sometimes I need to start tying all the objects together in the primary class that ties everything together before I can really wrap my head around the more nuanced decisions. I got in a pattern where I would let the flow of the program be entirely dictated by methods contained in the other Classes, but it didn't occur to me until this project to let some of the flow be handled by some of the methods within some of the other Classes. For instance, when it came time for me to code some way to handle the deck running out of cards, I was focused on where to put the method in the Saloon class, because that's where all my objects were created and that was the class that handled the flow of the app. I thought I would need to implement several different checks in several different places, because there are a lot of places where cards would be utilized. It later occurred to me that the check would only need to happen just before the program tried to draw from an empty deck, and that check would only need to be done in one place - the drawCard method.

I also ran into the opposite problem - sometimes making methods in other objects really doesn't make sense if the problem can be handled simply and cleanly within the primary logic driver. For instance, after I coded checks for busts or 21s for both the player and the dealer, I needed to write code for the other case - when neither the player nor the dealer had busted or gotten 21. I wrote the actual method to evaluate the winner in this case, called playerHasBetterHand, but I needed to be careful about how I implemented it - I needed to make sure it only implemented at the correct time. At first I tried to create a method that would implement my playerHasBetterHand, but I realized that the check would be much simpler with a one-line if statement in the Saloon class.

I was kind of shaky on abstract classes and interfaces (and I am by no means an expert now), but I saw a bit of the value of abstract classes vs. interfaces with this project. It made sense to me to make HandOfCards an abstract class, rather than an interface, because I knew there would be a lot of similarities between a players hand and a dealers hand - both need to hold Card objects, both need to display their cards, both need ways to refresh after a successful round. However, both a player hand and a dealer hand also need to display themselves in different ways - the user should be able to see both of their cards, but only one of the dealer's cards. It made sense to have both of the classes united by an abstract class because the body of most of the methods of each hand classes were identical, but it also made sense to keep the player hand and dealer hand separate and discrete. 

The Player and Dealer classes, on the other hand, both needed hitMe methods, but the hitMe methods would be very different - the body of each of those methods would need to be very different, because the Player hitMe method needed to take user input and the dealer hitMe method needed to function on logic alone. It made sense to use an interface rather than an abstract class here, since each hitMe method needed to be so different.